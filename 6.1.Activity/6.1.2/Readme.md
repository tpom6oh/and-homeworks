## Задача № 2
### Восстановление данных активити

Пора применить умения, полученные в прошлом домашнем задании, в существующем приложении.

**Задание:**

В этом задании нужно взять приложение из задания [4.1.2](https://github.com/netology-code/and-homeworks/tree/master/4.1.listview/4.1.2) и добавить механизм восстановления при повороте экрана.

1. Возьмите приложение из задания 4.1.2. Удалите какой-нибудь элемент и поверните экран. Вы увидите, что удаленный элемент появился в списке. Мы добавим механизм восстановления состояния активити, чтобы этого не происходило.
2. В `Bundle` нужно стараться сохранять как можно меньше информации, поэтому мы не будем сохранять весь список `List<Map<String, String>>`, а сохраним только последовательность индексов удаления. То есть каждый раз, когда мы будем удалять какой-то элемент, мы будем сохранять его индекс. Таким образом, при пересоздании активити мы сможем восстановить ее состояние.

**Выполнение**

1. В `Bundle` можно сохранять довольно много разных типов данных. Для нас наиболее удобным будет `ArrayList<Integer>`. Создайте поле класса с таким типом и инициализируйте его пустым списком.
2. При удалении элемента в `OnItemClickListener` сохраняйте его индекс в созданный выше список.
3. Переопределите метод `onSaveInstanceState`. Используйте метод `Bundle.putIntegerArrayList()`, чтобы сохранить данные поля, созданного в пункте 1.
4. Восстановите состояние в одном из подходящих методов. Для этого получите список удалений прошлой активити с помощью `Bundle.getIntegerArrayList()`. Пройдите по этому списку и удалите элементы с заданными индексами из поля `List<Map<String, String>>`.
5. Сообщите адаптеру об изменении содержимого соответствующим методом.

* В пункте 4 есть  тонкость: список удалений у нас имеет тип ArrayList<Integer>, то есть его элементы - Integer. Это полноценный объект и при использовании его в методе list.remove() будет произведена попытка удалить этот объект (Integer) из списка, что для нашего случая не имеет смысла, так как такого объекта в нашем списке нет и ничего удаляться не будет. Нам нужно вызывать метод list.remove() с параметром простого типа данных int, тогда будет производиться удаление по индексу.
Таким образом, в пункте 4 нам нужно быдет сделать что-нибудь подобное `simpleAdapterContent.remove(i.intValue());`

**Результаты и сдача домашнего задания**

В результате в приложении со списком из задания 4.1.2 удаленные элементы должны оставаться удаленными при перевороте устройства.
Выполненное домашнее задание загрузить на GitHub.
